<!doctype html>
<html lang='en-US'>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A novel keyboard for music</title>
<style>
	body {
		font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, roboto, noto, arial, sans-serif;
	}

	main {
		margin-left: auto;
		margin-right: auto;
		max-width: min(800px, 100%);
	}

	img {
		max-width: 100%;
		height: auto;
	}

	a[onclick]:not([href]) {
		cursor: pointer;
		color: rgb(51, 118, 34);
		text-decoration: underline;
	}

	:root {
		--key-scale: min(24vh, 8.51063829787vw);
	}

	.flex-v {
		/* https://stackoverflow.com/a/41059954/ */
		width: 100vw;
		margin-left: 50%;
		transform: translateX(-50%);

		display: flex;
		flex-direction: column;
		flex: 1;

		/* prevent long touch from selecting it */
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		user-select: none;
		overflow: hidden;
	}

	.flex-h {
		display: flex;
		margin: auto;
		height: var(--key-scale);
		flex: 1;
	}

	.keyd,
	.keyg,
	.keyp,
	.keyb,
	.keyn {
		/* margin counts twice. no collapsing either horizontally or vertically. border is internal as long as it is not huge */
		margin: calc(var(--key-scale) * 0.05);
		display: block;
		width: calc(var(--key-scale) * 0.9);
		height: calc(var(--key-scale) * 0.9);
		background-color: #f1f1f1;
		border-radius: calc(var(--key-scale) * 0.1);
		font-size: calc(var(--key-scale) * 0.4);
		text-align: center;
		padding: 0;
		/* necessary for mobile Safari, which otherwise starts the text in the center of the button */

		touch-action: none;
		/*pinch to zoom is extremely annoying*/
	}

	/* hover effect for mouse only. https://stackoverflow.com/questions/23885255/how-to-remove-ignore-hover-css-style-on-touch-devices */
	@media (pointer: fine) {
		.keyg:hover,
		.keyp:hover {
			background-color: #fff;
		}
	}

	.keybump {
		background-color: #e4e4e4
	}
	.keyd {
		color: #d0d0d0;
		pointer-events: none;
		/* otherwise you fail to release when mouse-up is over this button. https://stackoverflow.com/questions/62081666/the-event-of-the-document-is-not-triggered-when-it-is-on-a-disabled-element */
	}
	.keyg {
		color: #389900;
	}
	.keyb {
		color: #007aff;
	}
	.keyp {
		color: #9a00d2;
		transition: color 0.3s ease-out;
	}
	.keyd, .keyg, .keyp, .keyb {
		border-color: #efefef #d5d5d5 #ababab;
		border-style: solid;
	}
	.keyn {
		background-color: #f1f1f1;
	}

	.depress {
		border-color: #d0d0d0 #d5d5d5 #dadada;
		color: #00eeff;
		transition: color 0s;
	}

	.con {
		padding: 0;
		margin: 0;
		width: var(--key-scale);
		height: var(--key-scale);
		display: flex;
	}

	.r0 {
		--color: #e0e0ff;
	}
	.r1 {
		--color: #d5ffd5;
	}
	.r2 {
		--color: #ffc;
	}
	.r3 {
		--color: #ffe0e0;
	}

	.on {
		background: var(--color);
	}
	#piano {
		--w: calc(var(--key-scale) / 6);
		height: calc(var(--key-scale) * 0.12);
		width: 100vw;
		margin-top: 0;
	}

	.bkey{
		background: black;
		width: var(--w);
		height: calc(var(--key-scale) * 0.04);
		position: absolute;
		margin-top: 0;
		overflow: hidden;
		display: inline-block;
	}

	.ckey{
		width: var(--w);
		height: calc(var(--key-scale) * 0.08);
		position: absolute;
		margin-top: calc(var(--key-scale) * 0.04);
		display: inline-block;
		text-align: center;
	}
</style>

<body>
	<main id='main'><div class="flex-v" id="keyboard">
	<div class="flex-h"><div class="keyn" style="width: calc(var(--key-scale) * 0.5)"></div><button class="keyd" disabled>2</button><button class="keyd" disabled>3</button><button class="keyd" disabled>4</button><button class="keyd" disabled>5</button><button class="keyd" disabled>6</button><button class="keyg" id="Digit7">25</button><button class="keyg" id="Digit8">30</button><button class="keyg" id="Digit9">32</button><button class="keyg" id="Digit0">24</button><button class="keyg" id="Minus">18</button><button class="keyg" id="Equal">27</button><div class="keyn" style="width: calc(var(--key-scale) * .25)"></div>
	</div>
	<div class="flex-h"><div class="keyn" style="width: calc(var(--key-scale) * 0)"></div><button class="keyp" id='KeyQ'>7/6</button><button class="keyp" id='KeyW'>6/5</button><button class="keyp" id='KeyE'>5/4</button><button class="keyp" id='KeyR'>4/3</button><button class="keyp" id='KeyT'>3/2</button><button class="keyp" id='KeyY'>2/1</button><button class="keyg" id='KeyU'>15</button><button class="keyg" id='KeyI'>20</button><button class="keyg" id='KeyO'>16</button><button class="keyg" id='KeyP'>12</button><button class="keyg" id='BracketLeft'>9</button><div class="keyn" style="width: calc(var(--key-scale) * 0.75)"></div>
	</div>
	<div class="flex-h"><div class="keyn" style="width: calc(var(--key-scale) * 0.25)"></div><button class="keyp" id='KeyA'>6/7</button><button class="keyp" id='KeyS'>5/6</button><button class="keyp" id='KeyD'>4/5</button><button class="keyp keybump" id='KeyF'>3/4</button><button class="keyp" id='KeyG'>2/3</button><button class="keyp" id='KeyH'>1/2</button><button class="keyg keybump" id='KeyJ'>14</button><button class="keyg" id='KeyK'>10</button><button class="keyg" id='KeyL'>8</button><button class="keyg" id='Semicolon'>6</button><button class="keyg" id='Quote'>3</button><div class="keyn" style="width: calc(var(--key-scale) * 0.5)"></div>
	</div>
	<div class="flex-h"><div class="keyn" style="width: calc(var(--key-scale) * 0.75)"></div><button class="keyd" disabled>Z</button><button class="keyd" disabled>X</button><button class="keyd" disabled>C</button><button class="keyd" disabled>V</button><button class="keyd" disabled>B</button><button class="keyd" disabled>N</button><button class="keyg" id='KeyM'>7</button><button class="keyg" id='Comma'>5</button><button class="keyg" id='Period'>4</button><button class="keyg" id='Slash'>2</button><button class="keyg" id='ShiftRight'>1</button><div class="keyn" style="width: calc(var(--key-scale) * 0)"></div>
	</div>
</div>
<script>let Module = undefined;</script></main>


<script>
	function play(str) { Module._play_string(stringToNewUTF8(str)); }
	function play_on_keyboard(str) { reset_frequency(); Module._play_string_keyboard(stringToNewUTF8(str)); }

	//license for keyboard: 0BSD
	//this implementation doesn't support remapping keys or Web MIDI, because I'm lazy and Firefox doesn't have Web MIDI

	//Chrome and Edge have a 5-year old bug causing spurious keypresses. Just don't hold down harmony keys. A code solution would be to keep track of whether the harmonic keys are pressed. I didn't bother.
	//https://stackoverflow.com/q/50372849
	//https://bugs.chromium.org/p/chromium/issues/detail?id=843558

	let audioCtx = null;
	let incrementor_for_IDs = 1;

	if (typeof SharedArrayBuffer === 'undefined' && typeof Module !== 'undefined') {
		let p = document.createElement("p");
		p.textContent = "Your browser doesn't support SharedArrayBuffers, so the cool player piano and the demos won't work. You can still play the keyboard though. This is only a problem for Safari versions below 15.2.";
		keyboard.parentNode.insertBefore(p, keyboard);
	}

	let colors = [0, 0, 0, 0];
	let colors_excluding_blue_keys = [0, 0, 0, 0];

	function color_square(row, change, is_blue) {
		var list = document.getElementsByClassName("r" + row.toString() + " p" + (colors[row] + 6).toString());
		if (list.length)
			list[0].classList.remove("on");

		colors[row] += change;
		if (is_blue === 0)
			colors_excluding_blue_keys[row] += change;

		{
			var list = document.getElementsByClassName("r" + row.toString() + " p" + (colors[row] + 6).toString());
			if (list.length)
				list[0].classList.add("on");
		}
	}

	function ch_harmony(number, direction, is_blue) {
		let pm1 = direction ? 1 : -1;
		while (number % 2 == 0) {
			number /= 2;
			color_square(0, pm1, is_blue);
		}
		while (number % 3 == 0) {
			number /= 3;
			color_square(1, pm1, is_blue);
		}
		while (number % 5 == 0) {
			number /= 5;
			color_square(2, pm1, is_blue);
		}
		while (number % 7 == 0) {
			number /= 7;
			color_square(3, pm1, is_blue);
		}
	}

	function fraction_on_key(t) {
		let text = t.textContent;
		let split = text.split('/');
		if (typeof BigInt === 'undefined') {
			n = parseInt(split[0]);
			d = 1;
			if (split.length == 2)
				d = parseInt(split[1]);
			return [n, d];
		}
		else {
			n = BigInt(split[0]);
			d = 1n;
			if (split.length == 2)
				d = BigInt(split[1]);
			return [n, d];
		}
	}

	let recording = false;
	let recording_holder = [];
	let recording_start = 0;

	function stop_recording() {
		recording = false;
		recording_holder = [];
		recording_start = 0;
		recordbutton.textContent = "‚è∫ Record";
	}
	function start_recording() {
		comp.value = "-s0.0001";
		stop_recording();
		recordbutton.textContent = "Recording:";
		recording = true;
	}
	function play_button(t) {
		stop_recording();
		play_on_keyboard(comp.value);
	}
	function record_button(t) {
		if (recording)
			stop_recording();
		else start_recording();
	}

	function colors_to_primes() {
		if (typeof BigInt === 'undefined') {
			let n = 1;
			let d = 1;
			let primes = [2, 3, 5, 7];
			for (let i = 0; i < 4; ++i) {
				if (colors_excluding_blue_keys[i] < 0)
					d *= primes[i] ** (-colors_excluding_blue_keys[i]);
				else n *= primes[i] ** (colors_excluding_blue_keys[i]);
			}
			return [n, d];
		}
		else {
			let n = 1n;
			let d = 1n;
			let primes = [2n, 3n, 5n, 7n];
			for (let i = 0; i < 4; ++i) {
				if (colors_excluding_blue_keys[i] < 0)
					d *= primes[i] ** BigInt(- colors_excluding_blue_keys[i]);
				else n *= primes[i] ** BigInt(colors_excluding_blue_keys[i]);
			}
			return [n, d];
		}
	}

	function gcd(a, b) {
		if (b == 0) return a;
		return gcd(b, a % b);
	}
	function fraction_multiply(a, b){
		let n = a[0] * b[0];
		let d = a[1] * b[1];
		let gcdnd = gcd(n, d);
		return [n / gcdnd, d / gcdnd];
	}

	function fraction_to_string(a){
			if (Number(a[1]) !== 1)
				return a[0].toString() + "/" + a[1].toString();
			else
				return a[0].toString();
	}


	function interruptible_beep(t, volume = 1.0, type = 'sine') {
		let rational = fraction_on_key(t);
		let frequency = base_frequency;
		if (typeof BigInt === 'undefined') {
			frequency *= rational[0] / rational[1];
		}
		else {
			frequency *= Number(rational[0] * 100000n / rational[1]) / 100000;
		}
		if (recording) {
			let id = t.id;
			let time = performance.now();
			recording_holder[id] = [performance.now(), fraction_multiply(rational, colors_to_primes())];
			if (recording_start == 0)
				recording_start = time;
		}


		if (Module !== undefined && Module._play_interruptible_note !== undefined) {
			Module._play_interruptible_note(++incrementor_for_IDs, frequency);
			return incrementor_for_IDs;
		}

		//backup synthesizer in javascript, in case WASM fails. can have up to 20 ms latency, depending on your browser + OS.

		if (audioCtx === null) {
			var AudioContext = window.AudioContext // Default
		    || window.webkitAudioContext // Safari and old versions of Chrome
		    || false;

			audioCtx = new AudioContext();
		}

		volume *= 50.0 / frequency;
		//let oscillatorOptions = { frequency: frequency, type: type };
		//let oscillator = new OscillatorNode(audioCtx, oscillatorOptions); //not supported until Safari 14.1
		let oscillator = audioCtx.createOscillator();
		oscillator.type = type;
		oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

		//let gainNode = new GainNode(audioCtx); //not supported until Safari 14.1
		let gainNode = audioCtx.createGain();

		oscillator.connect(gainNode).connect(audioCtx.destination);

		let now = audioCtx.currentTime + 0.015; //0.015 is for web browser audio latency. the actual latency is higher, but this only causes jumps in the gain, not the oscillator, so it isn't too bad.
		let muteTime = 2.0 / Math.pow(frequency, 0.12);

		gainNode.gain.setValueAtTime(0, now);
		gainNode.gain.setTargetAtTime(volume, now, 2.0 / frequency);
		oscillator.start(now);
		console.log("tone at", frequency, "Hz");
		return { oscillator, gainNode, muteTime };
	};

	function stop_beep(id) {
		struct_of_stuff = beep_holder[id];

		if (recording) {
			if (recording_holder[id] === undefined){
				console.log("up stroke with no down stroke. could happen if you're starting recording in the middle of a note");
			}
			else {
				let time = performance.now();
				const [time_start, rational] = recording_holder[id];
				let time_from_start = Math.round(10 * (time_start - recording_start)).toString(); //don't worry too much about precision in html. 0.1 ms is good enough. and less text is better. also tied to: 10000n, and s0.0001
				let duration = Math.round(10 * (time - time_start)).toString();
				comp.value += "-[[t" + time_from_start + " >-t" + duration + "-" + fraction_to_string(rational) + "]";
				delete recording_holder[id];
			}
		}

		if (Module !== undefined && Module._mute_interruptible_note !== undefined) {
			Module._mute_interruptible_note(struct_of_stuff);
			delete beep_holder[id];
			return;
		}
		let now = audioCtx.currentTime;
		let muteTime = struct_of_stuff.muteTime;
		struct_of_stuff.gainNode.gain.setTargetAtTime(0, now + 0.02, muteTime / 10); //0.02 is a more conservative latency, since jumps here cause clicks
		struct_of_stuff.oscillator.stop(now + muteTime);
		delete beep_holder[id];
	}

	let beep_holder = [];
	let base_frequency = 82.5; //3/4 of 110 Hz. 100 can cause problems for people with absolute pitch. lower starting frequency is better, since I added 32 as a numerator. but watch out for the low end pitch. 20 Hz is already unmusical
	function reset_frequency() {
		for (let r = 0; r < 4; ++r) {
			color_square(r, -colors[r], 0);
		}
		base_frequency = 82.5;
	}
	reset_frequency();

	function multiply_all_green_keys(t, down) {
		let r = fraction_on_key(t);
		if (down === 0) {
			let temp = r[0];
			r[0] = r[1];
			r[1] = temp;
		}
		adjust_purple(t, down, 1);
		document.querySelectorAll('.keyg').forEach(function(g) {
			let f = fraction_on_key(g);
			let new_fraction = fraction_multiply(f, r);
			g.textContent = fraction_to_string(new_fraction);
		});
	}

	function adjust_harmony(i) {
		base_frequency *= i;

		//safety limiter for people who press random keys. actual musicians will want to disable this
		//thresholds are 1/4 and 4 the original frequency, to let you press each purple key twice.
		//I changed it to 1/8 and 4. because it's causing trouble for actual songs
		if (base_frequency < 10 || base_frequency > 331){
			reset_frequency();
		}
	}

	function numerator_down(t) {
		let handle = t.id;
		if (beep_holder[handle] !== undefined)
			stop_beep(handle);
		beep_holder[handle] = interruptible_beep(t);
	}
	function button_up(t) {
		let handle = t.id;
		if (beep_holder[handle] === undefined)
			return;
		stop_beep(handle);
	}

	function downpress(t) {
		t.classList.add("depress");
	}
	function release(t) {
		t.classList.remove("depress");
	}

	function adjust_purple(t, direction, is_blue) {
		const [i_, j_] = fraction_on_key(t);
		i = Number(i_);
		j = Number(j_);

		if (direction === 0) {
			i = Number(j_);
			j = Number(i_);
		}
		ch_harmony(i, 1, is_blue);
		ch_harmony(j, 0, is_blue);
		if (!is_blue)
			adjust_harmony(i / j); //adjust after changing colors - it might reset
	}

	function button_up_wrapper(t) {
		if (t.classList.contains("keyg")) {
			button_up(t);
			release(t);
		}
		else if (t.classList.contains("keyp")) {
			release(t);
		}
		else if (t.classList.contains("keyb")) {
			multiply_all_green_keys(t, 0);
			release(t);
		}
	}

	//returns true if pressed
	function button_down_wrapper(t) {
		if (t.classList.contains("keyg")) {
			numerator_down(t);
			downpress(t);
			return true;
		}
		else if (t.classList.contains("keyp")) {
			adjust_purple(t, true, 0);
			downpress(t);
			return true;
		}
		else if (t.classList.contains("keyb")) {
			multiply_all_green_keys(t, 1);
			downpress(t);
			return true;
		}
		return false;
	}

	addEventListener("keydown", (e) => {
		if (e.ctrlKey) return;
		if (e.target.tagName.toUpperCase() === 'INPUT') return;
		if (e.code === 'Slash' || e.code === 'Quote') e.preventDefault(); //prevent Quick find on Firefox
		if (e.repeat) return;

		let t = document.getElementById(e.code);
		if (t === null)
			return;
		button_down_wrapper(t);
	});

	addEventListener("keyup", (e) => {
		let t = document.getElementById(e.code);
		if (t === null)
			return;
		button_up_wrapper(t);
	});

	function pdown(id, t) {
		if (t.classList === undefined) //t can be an "HTMLDocument", if you drag the mouse into the chrome
			return;
		if (button_down_wrapper(t))
			pointerIdsPressed[id] = t;
	}
	function pup(id) {
		let t = pointerIdsPressed[id];
		if (t === undefined)
			return;
		button_up_wrapper(t);
		delete pointerIdsPressed[id];
	}

	let pointerIdsPressed = [];
	keyboard.addEventListener("pointerdown", (e) => {
		if (e.button !== 0)
			return;
		let id = e.pointerId;
		let t = e.target;
		//console.log(e);

		//https://stackoverflow.com/a/70737325/
		if (t.hasPointerCapture(id)) {
			t.releasePointerCapture(id);
		}
		if (t.classList.contains("con"))
			t = t.firstChild;
		pup(id);
		pdown(id, t);
	}); //https://github.com/w3c/pointerevents/issues/359#issuecomment-819828218 "pointerevent listeners are passive by default"

	//catch all mouseups, not just ones over the keyboard
	addEventListener("pointerup", (e) => {
		let id = e.pointerId;
		//prevent double tap to select
		//apparently, this doesn't work in pointerup. only touchend can prevent (forest fires) double tap to select?
		//let in_keyboard = t.closest("#keyboard");
		//if (in_keyboard !== null) {
		//	e.preventDefault();
		//}

		pup(id);
	});

	//https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not
	addEventListener("pointermove", (e) => {
		if (e.buttons === 0)
			return;
		//seems there's no obvious way to track what button is pressed; we'd need to store it. let's not bother. so right click drag will cause issues.
		let id = e.pointerId;
		let cached_event = pointerIdsPressed[id];
		let t = e.target;

		if (t.classList === undefined) //HTMLDocument avoidance
			return;
		if (t.classList.contains("con"))
			t = t.firstChild;

		if (t !== cached_event) {
			pup(id);
			pdown(id, t);
		}
	});

	//prevent double tap to select
	addEventListener("touchend", (e) => {
		let ts = e.changedTouches;
		for (let i = 0; i < ts.length; i++) {
			let t = ts[i].target;

			let in_keyboard = t.closest("#keyboard");
			if (in_keyboard !== null) {
				e.preventDefault();
			}
		};
	});

	//for a player piano. this function is called from emscripten
	function turn_button_on_off(str, on, ID) {
		let t = document.getElementById(str);
		//if (on)
		//	downpress(t);
		//else release(t);
		if (on) {
			const downEvent = new PointerEvent("pointerdown", {
			  pointerId: ID,
			  bubbles: true,
			});
			t.dispatchEvent(downEvent);
		}
		else {
			const upEvent = new PointerEvent("pointerup", {
			  pointerId: ID,
			  bubbles: true,
			});
			t.dispatchEvent(upEvent);
		}
	}

	{
		let keymultiples = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 24, 25, 27, 30, 32];
		for (let i = 0; i < keymultiples.length; ++i) {
			let length = (12 * Math.log(keymultiples[i]) / Math.log(2)).toString();
			let newDiv = document.createElement("div");
			newDiv.classList.add('ckey');
			newDiv.textContent = keymultiples[i].toString();
			newDiv.style="left:calc(var(--w) * " + length + ")";
			colorbar.appendChild(newDiv);
		}
	}

	//start at E. figure out the key positions
</script>
</body>

</html>